var N = null;var searchIndex = {};
searchIndex["futures_locks"]={"doc":"A library of [`Futures`]-aware locking primitives.  These locks can safely be  used in asynchronous environments like [`Tokio`].  When they block, they'll  only block a single task, not the entire reactor.","items":[[3,"Mutex","futures_locks","A Futures-aware Mutex.",N,N],[3,"MutexFut","","A `Future` representing a pending `Mutex` acquisition.",N,N],[3,"MutexGuard","","An RAII mutex guard, much like `std::sync::MutexGuard`.  The wrapped data can be accessed via its `Deref` and `DerefMut` implementations.",N,N],[3,"RwLock","","A Futures-aware RwLock.",N,N],[3,"RwLockReadFut","","A `Future` representing a pending `RwLock` shared acquisition.",N,N],[3,"RwLockWriteFut","","A `Future` representing a pending `RwLock` exclusive acquisition.",N,N],[3,"RwLockReadGuard","","An RAII guard, much like `std::sync::RwLockReadGuard`.  The wrapped data can be accessed via its `Deref` implementation.",N,N],[3,"RwLockWriteGuard","","An RAII guard, much like `std::sync::RwLockWriteGuard`.  The wrapped data can be accessed via its `Deref`  and `DerefMut` implementations.",N,N],[11,"new","","Create a new `Mutex` in the unlocked state.",0,[[["t"]],["mutex"]]],[11,"try_unwrap","","Consumes the `Mutex` and returns the wrapped data.  If the `Mutex` still has multiple references (not necessarily locked), returns a copy of `self` instead.",0,[[["self"]],["result",["mutex"]]]],[11,"get_mut","","Returns a reference to the underlying data, if there are no other clones of the `Mutex`.",0,[[["self"]],["option"]]],[11,"lock","","Acquires a `Mutex`, blocking the task in the meantime.  When the returned `Future` is ready, this task will have sole access to the protected data.",0,[[["self"]],["mutexfut"]]],[11,"try_lock","","Attempts to acquire the lock.",0,[[["self"]],["result",["mutexguard"]]]],[11,"with","","Acquires a `Mutex` and performs a computation on its guarded value in a separate task.  Returns a `Future` containing the result of the computation.",0,[[["self"],["f"]],["result",["spawnerror"]]]],[11,"with_local","","Like `with` but for Futures that aren't `Send`. Spawns a new task on a single-threaded Runtime to complete the Future.",0,[[["self"],["f"]],["result",["spawnerror"]]]],[11,"new","","Create a new `RwLock` in the unlocked state.",1,[[["t"]],["rwlock"]]],[11,"try_unwrap","","Consumes the `RwLock` and returns the wrapped data.  If the `RwLock` still has multiple references (not necessarily locked), returns a copy of `self` instead.",1,[[["self"]],["result",["rwlock"]]]],[11,"get_mut","","Returns a reference to the underlying data, if there are no other clones of the `RwLock`.",1,[[["self"]],["option"]]],[11,"read","","Acquire the `RwLock` nonexclusively, read-only, blocking the task in the meantime.",1,[[["self"]],["rwlockreadfut"]]],[11,"write","","Acquire the `RwLock` exclusively, read-write, blocking the task in the meantime.",1,[[["self"]],["rwlockwritefut"]]],[11,"try_read","","Attempts to acquire the `RwLock` nonexclusively.",1,[[["self"]],["result",["rwlockreadguard"]]]],[11,"try_write","","Attempts to acquire the `RwLock` exclusively.",1,[[["self"]],["result",["rwlockwriteguard"]]]],[11,"with_read","","Acquires a `RwLock` nonexclusively and performs a computation on its guarded value in a separate task.  Returns a `Future` containing the result of the computation.",1,[[["self"],["f"]],["result",["spawnerror"]]]],[11,"with_read_local","","Like `with_read` but for Futures that aren't `Send`.  Spawns a new task on a single-threaded Runtime to complete the Future.",1,[[["self"],["f"]],["result",["spawnerror"]]]],[11,"with_write","","Acquires a `RwLock` exclusively and performs a computation on its guarded value in a separate task.  Returns a `Future` containing the result of the computation.",1,[[["self"],["f"]],["result",["spawnerror"]]]],[11,"with_write_local","","Like `with_write` but for Futures that aren't `Send`.  Spawns a new task on a single-threaded Runtime to complete the Future.",1,[[["self"],["f"]],["result",["spawnerror"]]]],[11,"into","","",0,[[["self"]],["u"]]],[11,"to_owned","","",0,[[["self"]],["t"]]],[11,"clone_into","","",0,N],[11,"from","","",0,[[["t"]],["t"]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]],[11,"into","","",2,[[["self"]],["u"]]],[11,"from","","",2,[[["t"]],["t"]]],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"try_into","","",2,[[["self"]],["result"]]],[11,"get_type_id","","",2,[[["self"]],["typeid"]]],[11,"into_future","","",2,[[["self"]],["f"]]],[11,"into","","",3,[[["self"]],["u"]]],[11,"from","","",3,[[["t"]],["t"]]],[11,"try_from","","",3,[[["u"]],["result"]]],[11,"borrow","","",3,[[["self"]],["t"]]],[11,"borrow_mut","","",3,[[["self"]],["t"]]],[11,"try_into","","",3,[[["self"]],["result"]]],[11,"get_type_id","","",3,[[["self"]],["typeid"]]],[11,"into","","",1,[[["self"]],["u"]]],[11,"to_owned","","",1,[[["self"]],["t"]]],[11,"clone_into","","",1,N],[11,"from","","",1,[[["t"]],["t"]]],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"try_into","","",1,[[["self"]],["result"]]],[11,"get_type_id","","",1,[[["self"]],["typeid"]]],[11,"into","","",4,[[["self"]],["u"]]],[11,"from","","",4,[[["t"]],["t"]]],[11,"try_from","","",4,[[["u"]],["result"]]],[11,"borrow","","",4,[[["self"]],["t"]]],[11,"borrow_mut","","",4,[[["self"]],["t"]]],[11,"try_into","","",4,[[["self"]],["result"]]],[11,"get_type_id","","",4,[[["self"]],["typeid"]]],[11,"into_future","","",4,[[["self"]],["f"]]],[11,"into","","",5,[[["self"]],["u"]]],[11,"from","","",5,[[["t"]],["t"]]],[11,"try_from","","",5,[[["u"]],["result"]]],[11,"borrow","","",5,[[["self"]],["t"]]],[11,"borrow_mut","","",5,[[["self"]],["t"]]],[11,"try_into","","",5,[[["self"]],["result"]]],[11,"get_type_id","","",5,[[["self"]],["typeid"]]],[11,"into_future","","",5,[[["self"]],["f"]]],[11,"into","","",6,[[["self"]],["u"]]],[11,"from","","",6,[[["t"]],["t"]]],[11,"try_from","","",6,[[["u"]],["result"]]],[11,"borrow","","",6,[[["self"]],["t"]]],[11,"borrow_mut","","",6,[[["self"]],["t"]]],[11,"try_into","","",6,[[["self"]],["result"]]],[11,"get_type_id","","",6,[[["self"]],["typeid"]]],[11,"into","","",7,[[["self"]],["u"]]],[11,"from","","",7,[[["t"]],["t"]]],[11,"try_from","","",7,[[["u"]],["result"]]],[11,"borrow","","",7,[[["self"]],["t"]]],[11,"borrow_mut","","",7,[[["self"]],["t"]]],[11,"try_into","","",7,[[["self"]],["result"]]],[11,"get_type_id","","",7,[[["self"]],["typeid"]]],[11,"drop","","",3,[[["self"]]]],[11,"drop","","",2,[[["self"]]]],[11,"drop","","",6,[[["self"]]]],[11,"drop","","",7,[[["self"]]]],[11,"drop","","",4,[[["self"]]]],[11,"drop","","",5,[[["self"]]]],[11,"clone","","",0,[[["self"]],["mutex"]]],[11,"clone","","",1,[[["self"]],["rwlock"]]],[11,"deref_mut","","",3,[[["self"]],["t"]]],[11,"deref_mut","","",7,[[["self"]],["t"]]],[11,"deref","","",3,[[["self"]],["t"]]],[11,"deref","","",6,[[["self"]],["t"]]],[11,"deref","","",7,[[["self"]],["t"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"poll","","",2,[[["self"]],["poll"]]],[11,"poll","","",4,[[["self"]],["poll"]]],[11,"poll","","",5,[[["self"]],["poll"]]]],"paths":[[3,"Mutex"],[3,"RwLock"],[3,"MutexFut"],[3,"MutexGuard"],[3,"RwLockReadFut"],[3,"RwLockWriteFut"],[3,"RwLockReadGuard"],[3,"RwLockWriteGuard"]]};
initSearch(searchIndex);
